// lexer.cc # Auto-Generated by Overclad //
// NOTE: If you change the location of the include below, please reflect it in the include directive.
#include "ocpch.h"
#include "lexer.h"
const std::unordered_map<TokenType, std::regex> tokenPatterns = {
	{ TokenType::KEYWORD, std::regex("\\b(func|if|else|while|for|return|struct|use|let|var|mut|const|export|extern|import|package)\\b") },
	{ TokenType::IDENTIFIER, std::regex("[a-zA-Z_][a-zA-Z0-9_]*") },
	{ TokenType::ARROW, std::regex("(->|<-)") },
	{ TokenType::OPERATOR, std::regex("(==|!=|<=|>=|\\+=|-=|\\*=|/=|&&|\\|\\||\\+\\+|--|%=|&=|\\|=|\\^=|[+\\-*/=<>!&|^%])") },
	{ TokenType::SYMBOL, std::regex("[\\/<>!&|^%(){}\\[\\],.:;]") },
	{ TokenType::INTEGER, std::regex("\\b[0-9]+\\b") },
	{ TokenType::STRING, std::regex("\".*?\"") },
	{ TokenType::COMMENT, std::regex("//.*?\\n") },
	{ TokenType::WHITESPACE, std::regex("\\s+") },
};

std::vector<Token> tokens;
void InitLexer(const std::string& text)
{
	size_t currentPosition = 0;
	int col = 1;
	int line = 1;
	tokens.clear();
	currentPosition = 0;
	while (currentPosition < text.size()) {
		bool matched = false;

		for (const auto& [type, pattern] : tokenPatterns) {
		std::smatch match;
		std::string substring = text.substr(currentPosition);
		if (std::regex_search(substring, match, pattern, std::regex_constants::match_continuous)) {
			if (type != TokenType::COMMENT && type != TokenType::WHITESPACE) { // remove the comment part if you do not have comments
				tokens.push_back({ type, match.str(0), line, col });
			}

				currentPosition += match.length(0);
				for (size_t i = 0; i < match.length(0); ++i) {
					if (substring[i] == '\n') {
						line++;
						col = 1;
					} else {
						col++;
					}
				}
				matched = true;
				break;
			}
		}
		if (!matched) {
			throw std::runtime_error("Invalid token at position : " + std::to_string(currentPosition));
		}
	}
}
std::vector<Token>& LexAll(const std::string& text)
{
	try {
		InitLexer(text);
		return tokens;
	} catch (const std::exception& e) {
		std::cerr << "Error: " << e.what() << std::endl;
		return tokens;
	}
}
